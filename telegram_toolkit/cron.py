#!/usr/bin/env python3
import os
import shutil
import subprocess
from pathlib import Path
from typing import Optional
from .telegram import TelegramNotifier


class CronJob:
    """Simple cron job automation for UV Python projects."""

    def __init__(self, script_path: str, job_name: Optional[str] = None,
                 log_dir: str = "logs", error_notifications: bool = True):
        """
        Initialize cron job manager.

        Args:
            script_path: Path to Python script to run
            job_name: Name for the job (defaults to script filename)
            log_dir: Directory for log files
            error_notifications: Enable Telegram error notifications
        """
        self.script_path = Path(script_path).resolve()
        self.job_name = job_name or self.script_path.stem
        self.project_dir = Path.cwd()
        self.log_dir = self.project_dir / log_dir
        self.error_notifications = error_notifications

        # Create logs directory
        self.log_dir.mkdir(exist_ok=True)

        # Find UV executable
        self.uv_path = self._find_uv_executable()

    def _find_uv_executable(self) -> str:
        """Find UV executable path."""
        # Common UV installation paths
        uv_paths = [
            "/opt/homebrew/bin/uv",  # Homebrew on macOS
            shutil.which("uv"),      # System PATH
            "/usr/local/bin/uv",     # Local install
        ]

        for path in uv_paths:
            if path and Path(path).exists():
                return path

        raise RuntimeError("UV executable not found. Install UV or add to PATH.")

    def create_wrapper(self, wrapper_name: Optional[str] = None) -> Path:
        """
        Create wrapper script for cron automation.

        Args:
            wrapper_name: Name for wrapper script (defaults to run_{job_name}.sh)

        Returns:
            Path to created wrapper script
        """
        wrapper_name = wrapper_name or f"run_{self.job_name}.sh"
        wrapper_path = self.project_dir / wrapper_name

        # Generate wrapper script content
        wrapper_content = self._generate_wrapper_script()

        # Write wrapper script
        with open(wrapper_path, 'w') as f:
            f.write(wrapper_content)

        # Make executable
        wrapper_path.chmod(0o755)

        print(f"Created wrapper script: {wrapper_path}")
        return wrapper_path

    def _generate_wrapper_script(self) -> str:
        """Generate wrapper script content."""
        return f'''#!/bin/bash

# {self.job_name.title()} Automation Script
# Generated by telegram-automation-toolkit
# Designed for cron automation with logging and error reporting

# Set up paths
SCRIPT_DIR="$(cd "$(dirname "${{BASH_SOURCE[0]}}")" && pwd)"
LOG_FILE="$SCRIPT_DIR/{self.log_dir.name}/{self.job_name}.log"
ERROR_LOG="$SCRIPT_DIR/{self.log_dir.name}/error.log"

# Create logs directory if it doesn't exist
mkdir -p "$SCRIPT_DIR/{self.log_dir.name}"

# Function to log with timestamp
log_with_timestamp() {{
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}}

# Function to send error notification via Telegram
send_error_notification() {{
    local error_msg="$1"
    cd "$SCRIPT_DIR"

    # Load environment variables
    if [ -f ".env" ]; then
        export $(cat .env | grep -v '^#' | xargs)
    fi

    # Send error to Telegram if configured
    if [ ! -z "$TELEGRAM_BOT_TOKEN" ] && [ ! -z "$TELEGRAM_CHAT_ID" ]; then
        curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \\
            -d chat_id="$TELEGRAM_CHAT_ID" \\
            -d text="Error: {self.job_name.title()} failed: $error_msg" \\
            -d parse_mode="Markdown" > /dev/null 2>&1
    fi
}}

# Start logging
log_with_timestamp "Starting {self.job_name}..."

# Change to script directory
cd "$SCRIPT_DIR"

# Load environment variables from .env if it exists
if [ -f ".env" ]; then
    export $(cat .env | grep -v '^#' | xargs)
    log_with_timestamp "Loaded environment variables from .env"
fi

# Run the script
{self.uv_path} run python {self.script_path.relative_to(self.project_dir)} >> "$LOG_FILE" 2>> "$ERROR_LOG"
EXIT_CODE=$?

# Check if script completed successfully
if [ $EXIT_CODE -eq 0 ]; then
    log_with_timestamp "{self.job_name.title()} completed successfully"
else
    error_msg="{self.job_name.title()} failed with exit code $EXIT_CODE"
    log_with_timestamp "ERROR: $error_msg"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $error_msg" >> "$ERROR_LOG"
    {"send_error_notification \"$error_msg\"" if self.error_notifications else ""}
fi

# Keep logs under control (keep last 1000 lines for main log, 500 for errors)
if [ -f "$LOG_FILE" ]; then
    tail -n 1000 "$LOG_FILE" > "$LOG_FILE.tmp" && mv "$LOG_FILE.tmp" "$LOG_FILE"
fi

if [ -f "$ERROR_LOG" ]; then
    tail -n 500 "$ERROR_LOG" > "$ERROR_LOG.tmp" && mv "$ERROR_LOG.tmp" "$ERROR_LOG"
fi

exit $EXIT_CODE
'''

    def install_crontab(self, schedule: str, wrapper_name: Optional[str] = None) -> bool:
        """
        Install crontab entry for this job.

        Args:
            schedule: Cron schedule (e.g., "0 */6 * * *" for every 6 hours)
            wrapper_name: Name of wrapper script (defaults to run_{job_name}.sh)

        Returns:
            True if successful, False otherwise
        """
        wrapper_name = wrapper_name or f"run_{self.job_name}.sh"
        wrapper_path = self.project_dir / wrapper_name

        if not wrapper_path.exists():
            print(f"Wrapper script not found: {wrapper_path}")
            print("Run create_wrapper() first")
            return False

        cron_entry = f"{schedule} {wrapper_path.resolve()}"

        try:
            # Get current crontab
            result = subprocess.run(['crontab', '-l'], capture_output=True, text=True)
            current_cron = result.stdout if result.returncode == 0 else ""

            # Check if entry already exists
            if str(wrapper_path.resolve()) in current_cron:
                print(f"Cron entry already exists for {wrapper_path}")
                return True

            # Add new entry
            new_cron = current_cron.rstrip() + f"\n{cron_entry}\n"

            # Install new crontab
            proc = subprocess.Popen(['crontab', '-'], stdin=subprocess.PIPE, text=True)
            proc.communicate(input=new_cron)

            if proc.returncode == 0:
                print(f"Cron job installed: {cron_entry}")
                return True
            else:
                print(f"Failed to install cron job")
                return False

        except Exception as e:
            print(f"Cron installation failed: {e}")
            return False

    def show_logs(self, lines: int = 50, error_log: bool = False) -> None:
        """
        Show recent log entries.

        Args:
            lines: Number of lines to show
            error_log: Show error log instead of main log
        """
        log_file = self.log_dir / ("error.log" if error_log else f"{self.job_name}.log")

        if not log_file.exists():
            print(f"Log file not found: {log_file}")
            return

        try:
            result = subprocess.run(['tail', '-n', str(lines), str(log_file)],
                                  capture_output=True, text=True)
            if result.stdout:
                print(result.stdout)
            else:
                print("No log entries found")
        except Exception as e:
            print(f"Failed to read logs: {e}")

    def test_run(self) -> bool:
        """Test run the script to verify it works."""
        try:
            print(f"Testing {self.script_path}...")
            result = subprocess.run([self.uv_path, 'run', 'python', str(self.script_path)],
                                  cwd=self.project_dir, capture_output=True, text=True)

            if result.returncode == 0:
                print("Test run successful")
                if result.stdout:
                    print("Output:")
                    print(result.stdout)
                return True
            else:
                print("Test run failed")
                if result.stderr:
                    print("Error:")
                    print(result.stderr)
                return False
        except Exception as e:
            print(f"Test run failed: {e}")
            return False


def quick_setup(script_path: str, schedule: str, job_name: Optional[str] = None) -> bool:
    """
    Quick setup for a cron job - creates wrapper and installs crontab in one step.

    Args:
        script_path: Path to Python script
        schedule: Cron schedule
        job_name: Optional job name

    Returns:
        True if successful, False otherwise
    """
    try:
        job = CronJob(script_path, job_name)

        # Test the script first
        if not job.test_run():
            print("Script test failed, aborting setup")
            return False

        # Create wrapper
        wrapper_path = job.create_wrapper()

        # Install crontab
        return job.install_crontab(schedule)

    except Exception as e:
        print(f"Quick setup failed: {e}")
        return False
